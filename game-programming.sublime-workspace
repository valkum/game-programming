{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"rotat",
				"rotation"
			],
			[
				"tex",
				"textureColor"
			],
			[
				"uModel",
				"uModelViewProjectionMatrix"
			],
			[
				"get",
				"getProjectionMatrix"
			],
			[
				"move",
				"moveBack"
			],
			[
				"Hand",
				"HandleKeyEvents"
			],
			[
				"view",
				"viewMatrix"
			],
			[
				"color",
				"colorShader"
			],
			[
				"glB",
				"glBindVertexArray"
			],
			[
				"set",
				"setUniform"
			],
			[
				"sky",
				"skyboxShader"
			],
			[
				"cube",
				"cubemapTexture"
			],
			[
				"sim",
				"simpleCubeVBO"
			],
			[
				"Shader",
				"ShaderProgramCreator"
			],
			[
				"w",
				"window"
			],
			[
				"HandleM",
				"HandleMouseButtonEvents"
			],
			[
				"wo",
				"windowSize"
			],
			[
				"fb",
				"fbHeight"
			],
			[
				"include",
				"INCLUDE_DIRECTORIES"
			],
			[
				"CMAKE_CXX_",
				"CMAKE_CXX_FLAGS"
			],
			[
				"NANOVG",
				"NANOVG_LIBRARY_TYPE"
			],
			[
				"CMAKE_PRO",
				"CMAKE_PROJECT_NAME"
			],
			[
				"CMAKE_Cu",
				"CMAKE_CURRENT_SOURCE_DIR"
			],
			[
				"g_inwo",
				"_g_window_size"
			],
			[
				"g_window",
				"g_windowSize"
			],
			[
				"key",
				"keyCallback"
			],
			[
				"win",
				"g_window"
			],
			[
				"GLFW",
				"GLFWwindow"
			],
			[
				"Model",
				"ModelMatrix"
			],
			[
				"CURR",
				"CMAKE_CURRENT_SOURCE_DIR"
			],
			[
				"frag",
				"fragment_shader"
			],
			[
				"glf",
				"glfwGetTime"
			],
			[
				"v",
				"vertexShaderID"
			],
			[
				"fra",
				"fragmentShaderID"
			],
			[
				"vert",
				"vertexShaderID"
			],
			[
				"sha",
				"shader_programme"
			],
			[
				"look",
				"lookAt"
			],
			[
				"p",
				"perspective"
			],
			[
				"colo",
				"colorBuffer"
			],
			[
				"verte",
				"vertexBuffer"
			],
			[
				"Cg",
				"CGameState"
			],
			[
				"inc",
				"include"
			],
			[
				"CG",
				"CGame"
			],
			[
				"CGame",
				"CGameState"
			]
		]
	},
	"buffers":
	[
		{
			"file": "src/playstate.cpp",
			"settings":
			{
				"buffer_size": 10890,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/world/entity.cpp",
			"settings":
			{
				"buffer_size": 469,
				"line_ending": "Unix",
				"name": "#include \"entity.h\""
			}
		},
		{
			"file": "src/world/testobject.cpp",
			"settings":
			{
				"buffer_size": 43,
				"line_ending": "Unix",
				"name": "#include \"testobject.h\""
			}
		},
		{
			"contents": "#ifndef TESTOBJECT_H\n#define TESTOBJECT_H\n\n#endif",
			"settings":
			{
				"buffer_size": 49,
				"line_ending": "Unix",
				"name": "#ifndef TESTOBJECT_H"
			}
		},
		{
			"file": "include/world/entity.h",
			"settings":
			{
				"buffer_size": 426,
				"line_ending": "Unix",
				"name": "#ifndef ENTITY_H"
			}
		},
		{
			"contents": "/***********************************************************************\n * Copyright 2011-2013 Computer Graphics Group RWTH Aachen University. *\n * All rights reserved.                                                *\n * Distributed under the terms of the MIT License (see LICENSE.TXT).   *\n **********************************************************************/\n\n#pragma once\n#include <ACGL/ACGL.hh>\n#include <ACGL/Math/Math.hh>\n#include <glm/gtx/quaternion.hpp>\n\n#include \"CameraBase.hh\"\n#include \"MoveableObject.hh\"\n\n/*\n * What you definitly want to set:\n * - a position in 3D space (a vec3)\n * - a viewing direction, this can be defined by:\n *   - roll/pitch/jaw rotations\n *   - up/left/forward vectors\n * - the aspect ratio (width/height)\n *\n * What you maybe want to change:\n * - a lookAtDistance, this is internaly only used for the orthographic\n *   projection, can be be used externaly e.g. for field of view effects\n *   (if no focal distance is given, a default will be used, but often this\n *   value is not used at all), also a lookAt point can be calculated with this\n * - Stereo settings:\n *   - the eyedistance\n *   - the StereoMode\n * - Horizontal/Vertical FoV\n * - near- and far-clipping plane\n *\n * A Camera can calculate:\n * - a ViewMatrix\n * - a ProjectionMatrix for Mono view\n * - ProjectionMatrices for Stereo view\n * - etc.\n *\n *\n * Note: To get from world to camera space, the translation is applied first, then the\n *       rotation. getViewMatrix() provides one matrix for this.\n *       Other camera models rotate first and translate later (e.g. bundler)! The rotation\n *       is the same, the translation differs.\n *\n * TODO: support more stereo modes!\n */\n\nnamespace ACGL{\nnamespace Scene{\n\nclass ï¬‚ : public CameraBase, public MoveableObject\n{\n	public:\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Helping enums:\n        //\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        enum ProjectionMode\n        {\n            ISOMETRIC_PROJECTION   = 0,\n            PERSPECTIVE_PROJECTION\n        };\n\n        enum StereoMode\n        {\n            MONO = 0,\n            PARALLEL_SHIFT,\n            OFF_AXIS,\n            TOE_IN\n        };\n\n        enum Eye\n        {\n            EYE_LEFT = 0,\n            EYE_RIGHT\n        };\n        \n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Constructor / Destructor / save&store\n        //\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        /**\n         * Default Constructor of a camera.\n         */\n        GenericCamera();\n\n        /**\n         * Constructs a camera from a string which holds all camera parameters. Note that this sets the viewport which\n         * might not fix the currect screen!\n         */\n        GenericCamera( const std::string &_state );\n\n        /**\n         * Destructor of a camera.\n         */\n        ~GenericCamera() {}\n\n        /// Writes all internal state to one string\n        std::string storeStateToString() const;\n\n        /// Sets all internal state from a string\n        void setStateFromString( const std::string &_state );\n	\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Set / Get basic camera properties:\n        //\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n	\n        /**\n         * Set the distance between the pupils (only needed for stereo rendering).\n         * @param _interpupillaryDistance Inter pupil distance in meter(!) (distance between the centers of the eyes)\n         */\n        void setInterpupillaryDistance( float _interpupillaryDistance ) { mInterpupillaryDistance = _interpupillaryDistance; }\n        float getInterpupillaryDistance() const { return mInterpupillaryDistance; }\n        \n		/**\n         * Set the projection mode of the camera.\n         * @param _projection           New projection mode of the camera.\n		 */\n        void setProjectionMode( ProjectionMode _projection ) { mProjectionMode = _projection; }\n        ProjectionMode getProjectionMode() const { return mProjectionMode; }\n\n        /**\n         * Set the stereo mode of the camera. In mode MONO the set eye will get ignored (see below).\n         * @param _stereoMode New stereo mode of the camera.\n         */\n        void setStereoMode( StereoMode _stereoMode ) { mStereoMode = _stereoMode; }\n        StereoMode getStereoMode() const { return mStereoMode; }\n\n        /**\n         * Sets the currently active eye. In stereo mode MONO this setting is ignored.\n         * In the stereo modes (PARALLEL_SHIFT, OFF_AXIS, TOE_IN) it is used to\n         * define the default eye that is assumed for the generic get*Matrix() functions.\n         * (Matrices for specific eyes can still get queried directly without setting the\n         * eye explicitly before each call).\n         */\n        void setEye( Eye _eye ) { mCurrentEye = _eye; }\n        Eye getEye() const { return mCurrentEye; }\n	\n		/**\n         * Set the horizontal field of view of the camera in degree.\n         * vertical FoV will get (implicitly) changed!\n         * @param _fovh         New horizontal field of view of the camera.\n		 */\n        void setHorizontalFieldOfView( float _fovh );\n        float getHorizontalFieldOfView() const { return mHorizontalFieldOfView; }\n\n		/**\n         * Set the vertical field of view of the camera in degree.\n         * Horizontal FoV will get changed!\n         * @param _fovv         New vertical field of view of the camera.\n		 */\n        void setVerticalFieldOfView( float _fovv );\n        float getVerticalFieldOfView() const;\n	\n		/**\n        * Set the aspect ratio of the camera. The horizontal FoV stays the same, the\n		* vertical FoV gets updated.\n		* @param aspectRatio	New aspect ratio (width/height)\n		*/\n        void setAspectRatio( float _aspectRatio ) { mAspectRatio = _aspectRatio; }\n        float getAspectRatio() const { return mAspectRatio; }\n\n		/**\n		 * Set the near clipping plane of the camera.\n		 * The plane is defined only by a distance from the camera.\n         * @param _plane        New near clipping plane of the camera.\n		 */\n        void setNearClippingPlane( float _plane );\n        /// Gets the near clip distance\n        float getNearClippingPlane() const { return mNearClippingPlane; }\n\n		/**\n		 * Set the far clipping plane of the camera.\n		 * The plane is defined only by a distance from the camera.\n         * @param _plane        New far clipping plane of the camera.\n		 */\n        void setFarClippingPlane( float _plane );\n        /// Gets the far clip distance\n        float getFarClippingPlane() const { return mFarClippingPlane; }\n\n        /// Gets size of the viewport\n        virtual glm::uvec2 getViewportSize() const { return mViewportSize; }\n        /// Gets width of the viewport\n        unsigned int getViewportWidth() const { return mViewportSize.x; }\n        /// Gets height of the viewport\n        unsigned int getViewportHeight() const { return mViewportSize.y; }\n        /// Sets size of the viewport. NOTE: DOES NOT CHANGE THE ASPECT RATIO! Use resize() if you want to change that as well!\n        void setViewportSize( glm::uvec2 _size ) { mViewportSize = _size; }\n        /// Sets size of the viewport. NOTE: DOES NOT CHANGE THE ASPECT RATIO! Use resize() if you want to change that as well!\n        void setViewportSize( unsigned int _width, unsigned int _height ) { setViewportSize(glm::uvec2(_width, _height)); }\n\n        /// Sets new viewport size and calculates new aspect ratio\n        void resize(int _newWidth, int _newHeight) { setViewportSize(_newWidth, _newHeight); setAspectRatio(_newWidth / (float)_newHeight); }\n\n        /// The focal length is coupled to the sensor size in real cameras. As this camera does not model a\n        /// sensor size in mm, the focal length is given in pixels and is in relation to the viewports resolution.\n        /// This model is also used by bundler.\n        /// Note that this gives only useful results if the viewports aspect ratio is the same as the\n        /// projections aspect ratio!\n        float getFocalLenghtInPixel() const;\n\n        /// Sets the focal length in pixel relative to the viewport dimension. This will change the FoV.\n        /// See getFocalLenghtInPixel() for more information.\n        void setFocalLengthInPixel( float _focalLengthInPixel );\n\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Set / Get the matrices:\n        //\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        ///////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Generic rotation and translation matrices: In mono rendering these represent the camera.\n        // In stereo rendering these represent the virtual camera position between the two cameras\n        // actually used.\n        //\n\n        /// forward to MovableObject to implement the full CameraBase interface:\n        glm::vec3 getPosition() const { return MoveableObject::getPosition(); }\n\n        ///////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Generic view and projection matrices. These obey the set stereo/eye settings.\n        // (When in doubt, use these!)\n        //\n\n        /// Gets the currently active view matrix (depends on stereo mode and current eye)\n        virtual glm::mat4 getViewMatrix() const;\n        /// Gets the currently active view matrix (depends on stereo mode and current eye)\n        glm::mat4 getInverseViewMatrix() const;\n        /// Gets the currently active projection matrix (depends on stereo mode and current eye)\n        virtual glm::mat4 getProjectionMatrix() const;\n\n\n        ///////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Explicit view and projection matrices. These DON'T obey the set stereo/eye settings.\n        //\n\n        /// Gets the view matrix for non-stereo rendering EVEN IF A STEREO MODE IS SET!\n        glm::mat4 getMonoViewMatrix() const;\n        glm::mat4 getMonoInverseViewMatrix() const;\n\n        /**\n         * Compute a camera view matrix for stereo rendering.\n         * In stereo mode, the view matrix is the mono view matrix but also the shift\n         * by half the eye distance to the left/right and a small rotation inwards in\n         * case of toe in mode.\n         *\n         * These methods get the stereo matrix independent of the set mode for this camera.\n         */\n        glm::mat4 getStereoViewMatrix( bool _leftEye, StereoMode _stereoMode = OFF_AXIS ) const;\n        glm::mat4 getLeftStereoViewMatrix() const { return getStereoViewMatrix(true,  mStereoMode); }\n        glm::mat4 getRightStereoViewMatrix()const { return getStereoViewMatrix(false, mStereoMode); }\n        glm::mat4 getLeftParallelShiftStereoViewMatrix() const { return getStereoViewMatrix(true,  PARALLEL_SHIFT); }\n        glm::mat4 getRightParallelShiftStereoViewMatrix()const { return getStereoViewMatrix(false, PARALLEL_SHIFT); }\n        glm::mat4 getLeftOffAxisStereoViewMatrix()       const { return getStereoViewMatrix(true,  OFF_AXIS); }\n        glm::mat4 getRightOffAxisStereoViewMatrix()      const { return getStereoViewMatrix(false, OFF_AXIS); }\n        glm::mat4 getLeftToeInStereoViewMatrix()         const { return getStereoViewMatrix(true,  TOE_IN); }\n        glm::mat4 getRightToeInStereoViewMatrix()        const { return getStereoViewMatrix(false, TOE_IN); }\n\n        /// Gets the projection matrix for non-stereo rendering EVEN IF A STEREO MODE IS SET!\n        glm::mat4 getMonoProjectionMatrix() const;\n\n        /**\n         * Compute a camera projection matrix for stereo rendering.\n         * In stereo mode, the Cameras position is the point in the middle between the two eyes.\n         * So we just need one additional info to calculate two matrices:\n         */\n        glm::mat4 getStereoProjectionMatrix( bool _leftEye, StereoMode _stereoMode = OFF_AXIS ) const;\n        glm::mat4 getLeftStereoProjectionMatrix()              const { return getStereoProjectionMatrix(true,  mStereoMode); }\n        glm::mat4 getRightStereoProjectionMatrix()             const { return getStereoProjectionMatrix(false, mStereoMode); }\n        glm::mat4 getLeftParallelShiftStereoProjectionMatrix() const { return getStereoProjectionMatrix(true,  PARALLEL_SHIFT); }\n        glm::mat4 getRightParallelShiftStereoProjectionMatrix()const { return getStereoProjectionMatrix(false, PARALLEL_SHIFT); }\n        glm::mat4 getLeftOffAxisStereoProjectionMatrix()       const { return getStereoProjectionMatrix(true,  OFF_AXIS); }\n        glm::mat4 getRightOffAxisStereoProjectionMatrix()      const { return getStereoProjectionMatrix(false, OFF_AXIS); }\n        glm::mat4 getLeftToeInStereoProjectionMatrix()         const { return getStereoProjectionMatrix(true,  TOE_IN); }\n        glm::mat4 getRightToeInStereoProjectionMatrix()        const { return getStereoProjectionMatrix(false, TOE_IN); }\n\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n        //\n        // Set / Get properties that move the camera around (or rotate etc.)\n        //\n        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n        /**\n         * Look around with a mouse, works like a FPS camera:\n         *  No roll possible.\n         *  Up/down is limited to 90 degree.\n         * This method assumes there is no roll in the current camera rotation, if\n         * there is a roll component, it will get destroyed -> don't mix this\n         * way to stear with other, more flexible methods!\n         * @param _deltaX How much the mouse moved on the viewport (0..1, 1 = full viewport width)\n         * @param _deltaY How much the mouse moved on the viewport (0..1, 1 = full viewport height)\n         */\n        void FPSstyleLookAround( float _deltaX, float _deltaY );\n\n        // rotate around the target, x,y,z are angles to rotate by IN RADIANCE\n        // the rotation is around the global goordinate system (1,0,0 / 0,1,0 / 0,0,1)\n        // \"turntable style\" rotation if _x is set and _y,_z == 0\n        void rotateAroundTaget_GlobalAxes( float _x, float _y, float _z );\n\n        // rotate around the current coordinate system\n        void rotateAroundTaget_LocalAxes( float _x, float _y, float _z );\n\n	private:\n        ///\n        /// States: update the storeStateToString() & setStateFromString() functions whenever adding a new state!\n        ///\n\n		/// Current camera projection mode\n        ProjectionMode mProjectionMode;\n        /// stereo view mode\n        StereoMode mStereoMode;\n        /// Current eye\n        Eye mCurrentEye;\n		/// Current camera horizontal field of view\n        float mHorizontalFieldOfView;\n		/// Current aspect ratio: width/height.\n        float mAspectRatio;\n	\n        /// Distance of the eyes for stereo projection. In that case, the left eye is 0.5*InterpupillaryDistance\n        /// shifted to the left of position and the right eye is 0.5*InterpupillaryDistance to the right shifted.\n		/// We assume that 1 unit equals 1 meter. The mean eye distance is 6.5 cm == 0.065 units\n        float mInterpupillaryDistance;\n	\n		/// Current camera near clipping plane\n        float mNearClippingPlane;\n		/// Current camera far clipping plane\n        float mFarClippingPlane;\n\n        /// viewport in pixel:\n        glm::uvec2 mViewportSize;\n\n        // helper:\n        void rotateAroundTaget_helper( float _x, float _y, float _z, const glm::mat3 &_rotationAxes );\n};\n\nACGL_SMARTPOINTER_TYPEDEFS(GenericCamera)\n\n} // Scene\n} // ACGL\n\n",
			"file": "lib/acgl/include/ACGL/Scene/GenericCamera.hh",
			"file_size": 16178,
			"file_write_time": 130912940980000000,
			"settings":
			{
				"buffer_size": 16166,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/acgl/include/ACGL/Scene/MoveableObject.hh",
			"settings":
			{
				"buffer_size": 5628,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/acgl/src/ACGL/Scene/GenericCamera.cc",
			"settings":
			{
				"buffer_size": 16277,
				"line_ending": "Unix"
			}
		},
		{
			"file": "assets/shaders/skybox.fsh",
			"settings":
			{
				"buffer_size": 177,
				"line_ending": "Unix"
			}
		},
		{
			"file": "assets/shaders/skybox.vsh",
			"settings":
			{
				"buffer_size": 336,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/acgl/src/ACGL/OpenGL/Objects/Texture.cc",
			"settings":
			{
				"buffer_size": 29218,
				"line_ending": "Unix"
			}
		},
		{
			"file": "lib/acgl/include/ACGL/OpenGL/Objects/Texture.hh",
			"settings":
			{
				"buffer_size": 20536,
				"line_ending": "Unix"
			}
		},
		{
			"file": "include/TextureLoadStore.h",
			"settings":
			{
				"buffer_size": 478,
				"line_ending": "Unix"
			}
		},
		{
			"file": "src/TextureLoadStore.cpp",
			"settings":
			{
				"buffer_size": 1518,
				"line_ending": "Unix"
			}
		}
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 318.0,
		"last_filter": "install",
		"selected_items":
		[
			[
				"install",
				"Package Control: Install Package"
			],
			[
				"name",
				"Snippet: Namespace"
			],
			[
				"dis",
				"Package Control: Disable Package"
			],
			[
				"disa",
				"Package Control: Disable Package"
			],
			[
				"instal",
				"Package Control: Install Package"
			],
			[
				"sym",
				"CTags: Show Symbols (all)"
			],
			[
				"symb",
				"CTags: Show Symbols (all)"
			],
			[
				"show",
				"CTags: Show Symbols (all)"
			],
			[
				"ctags",
				"CTags: Show Symbols (all)"
			],
			[
				"tags",
				"CTags: Rebuild Tags"
			],
			[
				"lowe",
				"Convert Case: Lower Case"
			],
			[
				"re",
				"CTags: Rebuild Tags"
			],
			[
				"reb",
				"CTags: Rebuild Tags"
			],
			[
				"rebui",
				"CTags: Rebuild Tags"
			],
			[
				"packa",
				"Preferences: Browse Packages"
			],
			[
				"list",
				"Package Control: List Packages"
			],
			[
				"ad",
				"Project: Add Folder"
			]
		],
		"width": 475.0
	},
	"console":
	{
		"height": 126.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '2915d1851351e5ee549c20394736b442' + '8bc59f460fa1548d1514676163dafc88'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/Users/valkum/git/game-programming/include",
		"/Users/valkum/git/game-programming/src",
		"/Users/valkum/git/game-programming/src/world",
		"/Users/valkum/Downloads/acgl_examples/001-hello-world",
		"/Users/valkum/Downloads/acgl_examples/001-hello-world/Shader",
		"/Users/valkum/Downloads/acgl_examples/002-sampler-ubo-fbo",
		"/Users/valkum/Downloads/acgl_examples/002-sampler-ubo-fbo/Shader",
		"/Users/valkum/Downloads/acgl_examples/003-basic-texturing",
		"/Users/valkum/Downloads/acgl_examples/003-basic-texturing/Shader",
		"/Users/valkum/Downloads/acgl_examples/008-viewport-array",
		"/Users/valkum/Downloads/acgl_examples/standalone",
		"/Users/valkum/Downloads/acgl_examples/standalone/bin",
		"/Users/valkum/Downloads/acgl_examples/standalone/bin/shader"
	],
	"file_history":
	[
		"/Users/valkum/git/game-programming/assets/shaders/cube.vsh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Objects/ArrayBuffer.hh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/Scene/GenericCamera.hh",
		"/Users/valkum/git/game-programming/src/main.cpp",
		"/Users/valkum/git/game-programming/include/introstate.h",
		"/Users/valkum/git/game-programming/include/playstate.h",
		"/Users/valkum/git/game-programming/include/gamestate.h",
		"/Users/valkum/Downloads/acgl_examples/standalone/main.cc",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/Scene/GenericCamera.cc",
		"/Users/valkum/git/game-programming/src/introstate.cpp",
		"/Users/valkum/Downloads/acgl_examples/shared/main.hh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Objects/VertexArrayObject.hh",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Objects/VertexArrayObject.cc",
		"/Users/valkum/git/game-programming/assets/shaders/cube.fsh",
		"/Users/valkum/Downloads/acgl_examples/001-hello-world/Shader/HelloWorld.vsh",
		"/Users/valkum/Downloads/acgl_examples/001-hello-world/Shader/HelloWorld.fsh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/Base/CompileTimeSettings.hh",
		"/Users/valkum/git/game-programming/src/CMakeLists.txt",
		"/Users/valkum/Downloads/acgl_examples/001-hello-world/hello-world.cc",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Data/GeometryDataLoadStoreOBJ.cc",
		"/Users/valkum/git/game-programming/assets/geometry/cube.obj",
		"/Users/valkum/git/game-programming/src/TextureLoadStore.cpp",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Objects/TextureBuffer.hh",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Objects/Texture.cc",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Objects/ShaderProgram.hh",
		"/Users/valkum/git/game-programming/assets/shaders/skybox.fsh",
		"/Users/valkum/git/game-programming/assets/shaders/skybox.vsh",
		"/Users/valkum/Downloads/acgl_examples/003-basic-texturing/Shader/HelloWorld.fsh",
		"/Users/valkum/Downloads/acgl_examples/003-basic-texturing/Shader/HelloWorld.vsh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/Scene/FixedCamera.hh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/Scene/CameraBase.hh",
		"/Users/valkum/git/game-programming/include/TextureLoadStore.h",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Data/TextureData.cc",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Data/TextureLoadStore.cc",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Objects/Texture.hh",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Data/TextureLoadStoreDDS.cc",
		"/Users/valkum/git/game-programming/src/creator/TextureCubeMaoCreator.cpp",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Data/TextureLoadStore.hh",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Creator/Texture2DCreator.hh",
		"/Users/valkum/git/game-programming/include/Creator/TextureCubeMapCreator.h",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Creator/Texture2DCreator.cc",
		"/Users/valkum/git/game-programming/lib/acgl/src/ACGL/OpenGL/Data/TextureDataLoadStore.cc",
		"/Users/valkum/git/game-programming/include/main.h",
		"/Users/valkum/git/game-programming/src/game.cpp",
		"/Users/valkum/git/game-programming/include/game.h",
		"/Users/valkum/git/game-programming/include/helper.h",
		"/Users/valkum/git/game-programming/src/helper.cpp",
		"/Users/valkum/git/game-programming/src/playstate.cpp",
		"/Users/valkum/git/game-programming/src/gui/widget.cpp",
		"/Users/valkum/git/nanogui/ext/nanovg/CMakeLists.txt",
		"/Users/valkum/git/nanogui/ext/nanovg/CMake",
		"/Users/valkum/git/game-programming/src/gamestate.cpp",
		"/Users/valkum/git/game-programming/CMakeLists.txt",
		"/Users/valkum/git/game-programming/lib/nanovg/CMakeLists.txt",
		"/Users/valkum/git/game-programming/lib/nanovg/src/nanovg.h",
		"/Users/valkum/git/game-programming/lib/CMakeListsStaticIncludeNanoGUI.txt",
		"/Users/valkum/git/game-programming/lib/nanogui/CMakeLists.txt",
		"/Users/valkum/git/game-programming/lib/acgl/CMakeListsStaticInclude.txt",
		"/Users/valkum/git/game-programming/lib/nanogui/include/nanogui/slider.h",
		"/Users/valkum/git/game-programming/.travis.yml",
		"/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/Creator/ShaderProgramCreator.hh",
		"/Users/valkum/Library/Application Support/Sublime Text 3/Packages/User/C++.sublime-settings",
		"/Users/valkum/Library/Application Support/Sublime Text 3/Packages/User/Preferences.sublime-settings",
		"/Users/valkum/Library/Application Support/Sublime Text 3/Packages/User/YAML.sublime-settings",
		"/Users/valkum/git/game-programming/include/cube_fragment.glsl",
		"/Users/valkum/git/game-programming/assets/shaders/cube_vertex.glsl",
		"/Users/valkum/git/game-programming/README.md",
		"/Users/valkum/git/game-programming/CMake/modules/FindGLM.cmake",
		"/Users/valkum/git/game-programming/CMake/CMakeLists.txt",
		"/Users/valkum/Downloads/acgl_examples/006-auto-reload/Generated/Shader.fsh",
		"/Users/valkum/Downloads/acgl_examples/006-auto-reload/Generated/Texture.ppm",
		"/Users/valkum/git/game-programming/include/gui/guibase.h",
		"/Users/valkum/git/game-programming/.gitignore",
		"/Users/valkum/Downloads/acgl_examples/extern/acgl/src/lodepng/lodepng.cpp",
		"/Users/valkum/git/game-programming/tags",
		"/Users/valkum/git/game-programming/src/README.md",
		"/Users/valkum/git/game-programming/.ctags",
		"/Users/valkum/Library/Application Support/Sublime Text 3/Packages/User/CTags.sublime-settings",
		"/Users/valkum/git/game-programming/include/.ctags",
		"/Users/valkum/Library/Application Support/Sublime Text 3/Packages/User/SublimeLinter.sublime-settings",
		"/Users/valkum/git/game-programming/build.sh",
		"/Users/valkum/git/game-programming/CMakeList.txt",
		"/Users/valkum/git/game-programming/src/CMakeList.txt"
	],
	"find":
	{
		"height": 38.0
	},
	"find_in_files":
	{
		"height": 104.0,
		"where_history":
		[
			"/Users/valkum/git/game-programming/lib",
			"",
			"/Users/valkum/Downloads/acgl_examples,-/Users/valkum/Downloads/acgl_examples/extern/*",
			"/Users/valkum/Downloads/acgl_examples,-/Users/valkum/Downloads/acgl_examples/extern/",
			"/Users/valkum/Downloads/acgl_examples,-/Users/valkum/Downloads/acgl_examples/extern",
			"/Users/valkum/Downloads/acgl_examples",
			"/Users/valkum/git/game-programming/lib/acgl/,-/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/glloaders/*",
			"/Users/valkum/git/game-programming/lib/acgl/,-/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/glloaders/",
			"/Users/valkum/git/game-programming/lib/acgl/,-/Users/valkum/git/game-programming/lib/acgl/include/ACGL/OpenGL/glloaders",
			"/Users/valkum/git/game-programming/lib/acgl/",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"Position",
			"view ",
			"view",
			"colorShader",
			"target",
			"GL_TEXTURE_CUBE_MAP",
			"texture",
			"move",
			"fov",
			"g_camera",
			"camera",
			"text",
			"td::",
			"std::",
			"debug.hh",
			"Debug",
			"openGLCriticalError",
			"error",
			"abDataElements",
			"indices",
			"positionData",
			"positionDimension",
			"Array",
			"Vertex",
			"aNormal",
			"attachAttribute",
			"setAttributePointer",
			"glVertexAttribPointer",
			"Camera(",
			"FixedCamera(",
			"FixedCamera",
			"setTexture",
			":setTexture",
			"setTexture(",
			"setTexture",
			"attac",
			"bindTexture",
			"glActiveTexture",
			"normalsAsColorShader",
			"glBindTexture",
			"bind",
			"use",
			"cubeSideIsValid",
			"TextureCubeMap",
			"SharedTextureCubeMap",
			"CubeMap",
			"SharedTextureCubeMap",
			"glTexImage2D",
			"skymap.dds",
			"TextureCubeMap",
			"SharedTextureCubeMap",
			"CubeMap",
			"GL_INVALID_ENUM",
			"loadTextureCubeMapFromDDS(",
			"cube",
			"CubeMap",
			"loadTexture2D",
			"loadTextureCubeMapFromDDS",
			"cube",
			"Cube",
			"cube",
			"loadTe",
			"SharedTexture",
			"Cube",
			"CUBE",
			"CGame* game,",
			"self",
			"proc/self/exe\n\n",
			"nanovg/",
			"MACOS",
			"NANOGUI_BASE_DIR",
			"include",
			"src",
			"ACGL_BASE_DIR",
			"uvec",
			"ProgramID",
			"Vector3f",
			" = 0",
			"game"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": false,
		"replace_history":
		[
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 4,
			"sheets":
			[
				{
					"buffer": 0,
					"file": "src/playstate.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 10890,
						"regions":
						{
						},
						"selection":
						[
							[
								9239,
								9239
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 394.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "src/world/entity.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 469,
						"regions":
						{
						},
						"selection":
						[
							[
								296,
								296
							]
						],
						"settings":
						{
							"auto_name": "#include \"entity.h\"",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "src/world/testobject.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 43,
						"regions":
						{
						},
						"selection":
						[
							[
								43,
								43
							]
						],
						"settings":
						{
							"auto_name": "#include \"testobject.h\"",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 3,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 49,
						"regions":
						{
						},
						"selection":
						[
							[
								49,
								49
							]
						],
						"settings":
						{
							"auto_name": "#ifndef TESTOBJECT_H",
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "include/world/entity.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 426,
						"regions":
						{
						},
						"selection":
						[
							[
								56,
								56
							]
						],
						"settings":
						{
							"auto_name": "#ifndef ENTITY_H",
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "lib/acgl/include/ACGL/Scene/GenericCamera.hh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16166,
						"regions":
						{
						},
						"selection":
						[
							[
								1732,
								1732
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 4671.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "lib/acgl/include/ACGL/Scene/MoveableObject.hh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5628,
						"regions":
						{
						},
						"selection":
						[
							[
								948,
								934
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1337.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "lib/acgl/src/ACGL/Scene/GenericCamera.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 16277,
						"regions":
						{
						},
						"selection":
						[
							[
								1216,
								1203
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3734.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "assets/shaders/skybox.fsh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 177,
						"regions":
						{
						},
						"selection":
						[
							[
								11,
								11
							]
						],
						"settings":
						{
							"syntax": "Packages/OpenGL Shading Language (GLSL)/GLSL.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "assets/shaders/skybox.vsh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 336,
						"regions":
						{
						},
						"selection":
						[
							[
								295,
								295
							]
						],
						"settings":
						{
							"syntax": "Packages/OpenGL Shading Language (GLSL)/GLSL.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "lib/acgl/src/ACGL/OpenGL/Objects/Texture.cc",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 29218,
						"regions":
						{
						},
						"selection":
						[
							[
								376,
								380
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1339.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "lib/acgl/include/ACGL/OpenGL/Objects/Texture.hh",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 20536,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 3283.0,
						"zoom_level": 1.0
					},
					"stack_index": 13,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "include/TextureLoadStore.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 478,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 13,
					"file": "src/TextureLoadStore.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1518,
						"regions":
						{
						},
						"selection":
						[
							[
								529,
								529
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 52.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				}
			]
		}
	],
	"incremental_find":
	{
		"height": 23.0
	},
	"input":
	{
		"height": 32.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.CppYCM.3":
	{
		"height": 0.0
	},
	"output.cc":
	{
		"height": 98.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "game-programming.sublime-project",
	"replace":
	{
		"height": 42.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 257.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
